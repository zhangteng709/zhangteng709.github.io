<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title> __weak、__strong、 __block 区别 | SoaringInSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="icon" type="image/x-icon" href="<%- config.root %>/img/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden"> __weak、__strong、 __block 区别</h1><a id="logo" href="/.">SoaringInSky</a><p class="description">飞翔在广阔的天空！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"> __weak、__strong、 __block 区别</h1><div class="post-meta">Apr 26, 2015<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>#准备工作#</p>
<p>首先我定义了一个类 MyObject 继承 NSObject，并添加了一个属性 text，重写了description方法，返回 text 的值。这个主要是因为编译器本身对 NSString 是有优化的，创建的 string 对象有可能是静态存储区永不释放的，为了避免使用 NSString 引起一些问题，还是创建一个 NSObject 对象比较合适。<br>另外我自定义了一个 TLog 方法输出对象相关值，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define TLog(prefix,Obj) &#123;NSLog(@&quot;变量内存地址：%p, 变量值：%p, 指向对象值：%@, --&gt; %@&quot;,&amp;Obj,Obj,Obj,prefix);&#125;</span><br></pre></td></tr></table></figure>
<p>__weak<br>按 Ctrl+C 复制代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyObject *obj = [[MyObject alloc]init];//2</span><br><span class="line">	obj.text = @&quot;my-object&quot;;</span><br><span class="line">	TLog(@&quot;obj&quot;, obj);</span><br><span class="line"></span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">	TLog(@&quot;weakObj&quot;, weakObj);</span><br><span class="line"></span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">		&#125;;</span><br><span class="line">testBlock();</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure>
<p>按 Ctrl+C 复制代码<br>变量内存地址：0x7fff58c8a9f0, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff58c8a9e8, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; weakObj<br>变量内存地址：0x7f8e030804c0, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x7f8e030804c0, 变量值：0x0, 指向对象值：(null), –&gt; weakObj - block<br>从上面的结果可以看到</p>
<p>block 内的 weakObj 和外部的 weakObj 并不是同一个变量<br>block 捕获了 weakObj 同时也是对 obj 进行了弱引用，当我在 block 外把 obj 释放了之后，block 内也读不到这个变量了<br>当 obj 赋值 nil 时，block 内部的 weakObj 也为 nil 了，也就是说 obj 实际上是被释放了，可见 __weak 是可以避免循环引用问题的<br>接下来我们再看第二段代码</p>
<p>复制代码<br><figure class="highlight plain"><figcaption><span>*obj </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">obj.text = @&quot;my-object&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;, obj);</span><br><span class="line">    </span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">TLog(@&quot;weakObj-0&quot;, weakObj);</span><br><span class="line">    </span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TLog(@&quot;weakObj-1&quot;, weakObj);</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;weakObj-2&quot;, weakObj);</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;weakObj-3&quot;, weakObj);</span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>复制代码<br>变量内存地址：0x7fff5d7b2d18, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-0<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-1<br>变量内存地址：0x7fcf78f0f520, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x7fff5d7b2bb8, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; strongObj - block<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-2<br>变量内存地址：0x7fcf78f0f520, 变量值：0x0, 指向对象值：(null), –&gt; weakObj - block<br>变量内存地址：0x7fff5d7b2bb8, 变量值：0x0, 指向对象值：(null), –&gt; strongObj - block<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x0, 指向对象值：(null), –&gt; weakObj-3<br>复制代码</p>
<p>如果你看过 AFNetworking 的源码，会发现 AFN 中作者会把变量在 block 外面先用 <strong>weak 声明，在 block 内把前面 weak 声明的变量赋值给 </strong>strong 修饰的变量这种写法。</p>
<p>从上面例子我们看到即使在 block 内部用 strong 强引用了外面的 weakObj ，但是一旦 obj 释放了之后，内部的 strongObj 同样会变成 nil，那么这种写法又有什么意义呢？</p>
<p>下面再看一段代码：</p>
<p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;my-object&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;, obj);</span><br><span class="line">    </span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">TLog(@&quot;weakObj-0&quot;, weakObj);</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">   </span><br><span class="line">   sleep(3);</span><br><span class="line">   </span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;------ sleep 1s&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">obj = nil;</span><br><span class="line">TLog(@&quot;weakObj-1&quot;, weakObj);</span><br><span class="line">NSLog(@&quot;------ sleep 5s&quot;);</span><br><span class="line">sleep(5);</span><br><span class="line">TLog(@&quot;weakObj-2&quot;, weakObj);</span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>复制代码<br>变量内存地址：0x7fff58e2ad18, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff58e2ad10, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj-0<br>变量内存地址：0x7fa2b1e80710, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x700000093de8, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; strongObj - block<br>—— sleep 1s<br>变量内存地址：0x7fff58e2ad10, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj-1<br>—— sleep 5s<br>变量内存地址：0x7fa2b1e80710, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x700000093de8, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; strongObj - block<br>变量内存地址：0x7fff58e2ad10, 变量值：0x0, 指向对象值：(null), –&gt; weakObj-2<br>复制代码</p>
<p>代码中使用 sleep 来保证代码执行的先后顺序。</p>
<p>从结果中我们可以看到，只要 block 部分执行了，即使我们中途释放了 obj，block 内部依然会继续强引用它。对比上面代码，也就是说 block 内部的 __strong 会在执行期间进行强引用操作，保证在 block 内部 strongObj 始终是可用的。这种写法非常巧妙，既避免了循环引用的问题，又可以在 block 内部持有该变量。</p>
<p>综合两部分代码，我们平时在使用时，常常先判断 strongObj 是否为空，然后再执行后续代码，如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   if (strongObj) &#123;</span><br><span class="line">       // do something ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这种方式先判断 Obj 是否被释放，如果未释放在执行我们的代码的时候保证其可用性。</p>
<p>###__block<br>先上代码</p>
<p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;my-object-1&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">TLog(@&quot;blockObj -1&quot;,blockObj);</span><br><span class="line"></span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">    MyObject *obj2 = [[MyObject alloc]init];</span><br><span class="line">    obj2.text = @&quot;my-object-2&quot;;</span><br><span class="line">    TLog(@&quot;obj2&quot;,obj2);</span><br><span class="line">    blockObj = obj2;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,testBlock);</span><br><span class="line">TLog(@&quot;blockObj -2&quot;,blockObj);</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj -3&quot;,blockObj);</span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>复制代码<br>变量内存地址：0x7fff5021a9f0, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; obj<br>变量内存地址：0x7fff5021a9e8, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj -1<br>&lt;<strong>NSMallocBlock</strong>: 0x7ff6b48d8c20&gt;<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj -2<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj - block<br>变量内存地址：0x7fff5021a7f8, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; obj2<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; blockObj - block<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; blockObj -3<br>复制代码</p>
<p>可以看到在 block 声明前后 blockObj 的内存地址是有所变化的，这涉及到 block 对外部变量的内存管理问题，大家可以看扩展阅读中的几篇文章，对此有较深入的分析。</p>
<p>下面来看看 __block 能不能避免循环引用的问题</p>
<p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;11111111111111&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">&#125;;</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj&quot;,blockObj);</span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>变量内存地址：0x7fff57eef9f0, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; obj<br>变量内存地址：0x7ff86c918a88, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; blockObj - block<br>变量内存地址：0x7ff86c918a88, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; blockObj</p>
<p>当外部 obj 指向 nil 的时候，obj 理应被释放，但实际上 blockObj 依然强引用着 obj，obj 其实并没有被真正释放。因此使用 __block 并不能避免循环引用的问题。</p>
<p>但是我们可以通过手动释放 blockObj 的方式来释放 obj，这就需要我们在 block 内部将要退出的时候手动释放掉 blockObj ，如下这种形式</p>
<p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;11111111111111&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">    blockObj = nil;</span><br><span class="line">&#125;;</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj&quot;,blockObj);</span><br></pre></td></tr></table></figure></p>
<p>复制代码</p>
<p>必须记住在 block 底部释放掉 block 变量，这其实跟 MRC 的形式有些类似了，不太适合 ARC这种形式既能保证在 block 内部能够访问到 obj，又可以避免循环引用的问题，但是这种方法也不是完美的，其存在下面几个问题</p>
<p>当在 block 外部修改了 blockObj 时，block 内部的值也会改变，反之在 block 内部修改 blockObj 在外部再使用时值也会改变。这就需要在写代码时注意这个特性可能会带来的一些隐患<br>__block 其实提升了变量的作用域，在 block 内外访问的都是同一个 blockObj 可能会造成一些隐患</p>
<p>总结！！！<br><strong>weak 本身是可以避免循环引用的问题的，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong 的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题。</p>
<p><strong>block 本身无法避免循环引用的问题，但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题。另外一点就是 </strong>block 修饰的变量在 block 内外都是唯一的，要注意这个特性可能带来的隐患。</p>
<p>但是<strong>block有一点：这只是限制在ARC环境下。在非arc下，</strong>block是可以避免引用循环的</p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=/img/BTCQR.png## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png&amp;BTCKEY=null&amp;PayPal=https://github.com/zhangteng709" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2015/04/26/Swift中的内存泄漏/">Swift中的内存泄漏</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/09/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/my-new/">my new post</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/iOS-检测内存泄漏的方式/">iOS  检测内存泄漏的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/26/Swift中的内存泄漏/">Swift中的内存泄漏</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/26/weak、-strong、-block-区别/"> __weak、__strong、 __block 区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.jianshu.com/u/5c04d3ff30b6" title="我的简书" target="_blank">我的简书</a><ul></ul><a href="http://blog.devtang.com/" title="唐巧的博客" target="_blank">唐巧的博客</a><ul></ul><a href="http://awhisper.github.io/" title="味精" target="_blank">味精</a><ul></ul><a href="https://www.52pojie.cn/" title="吾爱破解" target="_blank">吾爱破解</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">SoaringInSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="28,132,203" opacity="0.6" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>