<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Swift中的内存泄漏 | SoaringInSky</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="icon" type="image/x-icon" href="<%- config.root %>/img/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Swift中的内存泄漏</h1><a id="logo" href="/.">SoaringInSky</a><p class="description">飞翔在广阔的天空！</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Swift中的内存泄漏</h1><div class="post-meta">Apr 26, 2015<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>Swift使用自动引用计数（ARC）来管理应用程序的内存使用。在大多是情况下，并不需要考虑内存的管理。当实例不再需要的时候，ARC会自动释放这些实例所使用的内存。<br>但ARC并不是绝对安全的。下面两种情况会发生内存泄露。</p>
<h3 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    var anima:Animail?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Person被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animail: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var peron:Person?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Animail初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animail被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">var animail:Animail? = Animail.init()</span><br><span class="line">person?.anima = animail</span><br><span class="line">animail?.peron = person</span><br><span class="line">person = nil;</span><br><span class="line">animail = nil;</span><br><span class="line">//测试结果（deinit未调用，则内存泄露）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Animail初始化完成</span><br></pre></td></tr></table></figure>
<p><strong>解决办法：使用弱引用<br>只需要将上述例子Person类的anima变量加上关键字weak，或者将Animail类的peron变量加上关键字weak。<br>当A类中包含有B类的弱引用的实例，同时，B类中存在A的强引用实例时，如果A释放，也不会影响B的释放。但A的内存回收要等到B的实例释放后才可以回收。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    var anima:Animail?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Person被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animail: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var peron:Person?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Animail初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animail被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">var animail:Animail? = Animail.init()</span><br><span class="line">person?.anima = animail</span><br><span class="line">animail?.peron = person</span><br><span class="line">person = nil</span><br><span class="line">animail = nil</span><br><span class="line"></span><br><span class="line">//测试结果（deinit调用，内存释放）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Animail初始化完成</span><br><span class="line">//Person被释放了</span><br><span class="line">//Animail被释放了</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h3><p><strong>将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例，也会发生强引用循环。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var anima:Animail?</span><br><span class="line">    var age:String?</span><br><span class="line"></span><br><span class="line">    lazy var block:(() -&gt; String) = &#123;</span><br><span class="line">        if let text = self.age &#123;</span><br><span class="line">            return text</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;text is nil&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.age= name</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">person?.block()</span><br><span class="line">person = nil</span><br><span class="line">//测试结果（deinit未调用，则内存泄露）</span><br><span class="line">//Person初始化完成</span><br></pre></td></tr></table></figure>
<p><strong>解决办法：使用闭包捕获列表<br>当闭包和实例之间总是引用对方并且同时释放时，定义闭包捕获列表为无主引用。但捕获引用可能为nil时，定义捕获列表为弱引用。弱引用通常是可选类型，并且在实例释放后被设置为nil。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var anima:Animail?</span><br><span class="line">    var age:String?</span><br><span class="line"></span><br><span class="line">    lazy var block:(() -&gt; String) = &#123;[weak self] in</span><br><span class="line">        </span><br><span class="line">        if let text = self?.jValue &#123;</span><br><span class="line">            </span><br><span class="line">            return text</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;text is nil&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.age= name</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">person?.block()</span><br><span class="line">person = nil</span><br><span class="line">//测试结果（deinit调用，内存释放）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Person被释放了</span><br></pre></td></tr></table></figure>
<ol>
<li>e.g<br> 我们从这个简单的实例开始：ViewController 中有一个 CustomView 类型的成员属性变量，同时 CustomView 有一个点击事件的闭包函数 onTap ：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CustomView:UIView&#123; </span><br><span class="line">    var onTap:(()-&gt;Void)?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController:UIViewController&#123; </span><br><span class="line">    let customView = CustomView() </span><br><span class="line">    var buttonClicked = false</span><br><span class="line"></span><br><span class="line">    func setupCustomView()&#123;</span><br><span class="line">        var timesTapped = 0</span><br><span class="line">        customView.onTap = &#123; _ in </span><br><span class="line">            timesTapped += 1 </span><br><span class="line">            print(&quot;button tapped \(timesTapped) times&quot;)</span><br><span class="line">            self.buttonClicked = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在给闭包函数 onTap 赋值的语句中我们对 buttonClicked 进行了赋值，这就导致了对 self 的强引用。但是我们仔细思考后就不难发现其中的问题： self 引用了 customView 变量，然后 customView 变量的饮用了 onTap 闭包，最后 onTap 闭包引用了 self 。其结果类似下图：</p>
<p><img src="/img/aaa.png" alt=""></p>
<p>上图中你能清晰的看见循环结构，这导致程序退出的时候不能正常的销毁内存导致内存泄漏的发生。</p>
<h4 id="隐藏的循环"><a href="#隐藏的循环" class="headerlink" title="隐藏的循环"></a>隐藏的循环</h4><p>除了上面那种明显的循环引用有些闭环隐藏的更深也更隐蔽。解决这个问题的关键就是：在对闭包赋值的时候问自己谁是闭包的拥有者，然后向上溯源到根节点。</p>
<p>下面我们来看最常见 UITableView 中隐藏的循环（最常见的往往越容易被忽略）。一般情况下我们都是在 UIViewController 中新建 UITableView 实例少数情况下也会使用 UITableViewController ，但是不管哪种情形我们都会新建自定义的 UITableViewCell 。</p>
<p>下面的代码中我们新建了一个名为 CustomCell 的 UITableViewCell 子类，该类中包含了一个 UIButton实例属性以及按键点击事件的闭包属性 onButtonTap。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CustomCell: UITableViewCell &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var customButton: UIButton!</span><br><span class="line">    var onButtonTap:(()-&gt;Void)?</span><br><span class="line"></span><br><span class="line">    @IBAction func buttonTap()&#123;</span><br><span class="line">        onButtonTap?()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///然后我们在 ViewController 对该闭包赋值：</span><br><span class="line">class ViewController: UITableViewController &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;CustomCell&quot;, for: indexPath) as! CustomCell</span><br><span class="line">        cell.onButtonTap = &#123; _ in</span><br><span class="line">            self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们对 onButtonTap闭包进行溯源：谁拥有该闭包？毫无疑问是 CustomCell类的实例 cell。而 cell 又是属于 tableView，tableView又属于 self 所代表的UITableViewController 实例。</p>
<p>正如下图表现的那样，这里也有一个循环引用，只不过分析路线更长所以显得更隐蔽。</p>
<p><img src="/img/bbb.png" alt=""></p>
<p>GCD 中的闭包分析<br>如果你以前用过 GCD 的话，那么你能一眼判断下面代码是否有循环引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123;</span><br><span class="line">        self.navigationController?.pushViewController(NewViewController())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的使用溯源法分析闭包：拥有闭包的对象是 DispatchQueue 单例，该单例并不被 ViewController 任何属性所引用，但DispatchQueue 单例的闭包中却持有了 self。虽然我们不知道该单例的具体实现，但是我们清楚该异步闭包会在2s后被执行一次，执行完成之后该闭包就会释放对 self 的引用。所以我们由此可以断定这段闭包代码是不存在循环引用问题的。</p>
<p><strong>这部分的代码逻辑和分析同样适用于 UIView 的动画闭包函数中</strong></p>
<h4 id="Alamofire-中的闭包"><a href="#Alamofire-中的闭包" class="headerlink" title="Alamofire 中的闭包"></a>Alamofire 中的闭包</h4><p>Alamofire 可以说是 Swift 网络处理中最常用的第三方库了，其中的请求处理中同样涉及到闭包函数。下面这段代码是请求登陆接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Alamofire.request(&quot;https://yourapi.com/login&quot;, method: .post, parameters: [&quot;email&quot;:&quot;test@gmail.com&quot;,&quot;password&quot;:&quot;1234&quot;]).responseJSON &#123; (response:DataResponse&lt;Any&gt;) in</span><br><span class="line">    if response.response?.statusCode == 200 &#123;</span><br><span class="line">        self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //Show alert</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码中的闭包又是属于哪个对象？这里我们需要深入 Alamofire 的实现中去探寻。首先 request方法会返回一个 DataRequest类型对象，而该对象的 responseJSON方法中将闭包作为参数 completionHandler传入，最后该闭包存入了 OperationQueue 类型的队列 queue 中，闭包执行完成后会自动从队列中移除。由此我们可知：闭包被 queue所持有并且一次执行后就移除了，此处不存在循环引用。</p>
<p>循环引用的解决<br>为了打破循环引用带来的内存泄漏问题，根本途径就是破坏该循环，将某个对象对另一个对象的强引用去除。在闭包环境的循环问题，我们都倾向于将闭包中的强引用去除，毕竟这简单而且看起来更直观。</p>
<p>为了实现该目的，我们在闭包捕获的上下文变量中做文章。我们使用关键词 weak、unowned 来打破循环。例如上文中提到的 UITableView ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.onButtonTap = &#123; [unowned self] in</span><br><span class="line">    self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉两个关键词存在着明显的区别 weak 是可选值而 unowned 则一定不为可选值，换句话说 weak 关键词所指对象可能为 nil 而 unowned 则一定不能是 nil，因此在选用的时候需要认真考虑一下。一般来说如果闭包生命周期不长于其捕获的上下文变量的生命周期我们会使用 unowned，否则我们选择 weak 。</p>
<p>内存泄漏的调试<br>上面我们分析了大部分闭包中的循环引用问题，我们得知并不是所有的情况下都会导致内存泄漏。如果在我们使用了第三方库尤其是一些私有实现库的情况下，这部分的分析在代码层面将变的很困难并且工作量很大。好在Xcode为我们提供的调试工具，在工程运行的情况下，我们在调试区域可以找到如下图所示按键：</p>
<p><img src="/img/ccc.png" alt=""></p>
<p>在 UITableView 的示例中，如果我们移除闭包中的 unowned 或者 weak 的话，你就能在左侧看见下图</p>
<p><img src="/img/ddd.png" alt=""></p>
<p>上图中的左侧感叹号表明了这里存/Users/ghzz/hexo/work/source/img/aaa.png<br>在着内存泄漏的情况，这样你就要去查看代码了。当然你又内存泄漏但是没有感叹号标记的情况也是完全有可能的，此时你就要启用内存分析工具了并且分析内存中的对象，这些对象是否应该存在。</p>
<p>文章参考<a href="https://segmentfault.com/a/1190000008924142" target="_blank" rel="noopener">Swift闭包中的内存泄漏 </a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=null&amp;BTCQR=/img/BTCQR.png## Path of Bitcoin QRcode image, e.g. /img/BTCQR.png&amp;BTCKEY=null&amp;PayPal=https://github.com/zhangteng709" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Swift/">Swift</a></div><div class="post-nav"><a class="pre" href="/2015/05/07/iOS-常用锁总结/">iOS 常用锁总结</a><a class="next" href="/2015/04/26/weak、-strong、-block-区别/"> __weak、__strong、 __block 区别</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/04/Swift-中关键字/">Swift 中关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/02/iOS-检测内存泄漏的方式/">iOS  检测内存泄漏的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/05/07/iOS-常用锁总结/">iOS 常用锁总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/26/Swift中的内存泄漏/">Swift中的内存泄漏</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/04/26/weak、-strong、-block-区别/"> __weak、__strong、 __block 区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.jianshu.com/u/5c04d3ff30b6" title="我的简书" target="_blank">我的简书</a><ul></ul><a href="http://blog.devtang.com/" title="唐巧的博客" target="_blank">唐巧的博客</a><ul></ul><a href="http://awhisper.github.io/" title="味精" target="_blank">味精</a><ul></ul><a href="https://www.52pojie.cn/" title="吾爱破解" target="_blank">吾爱破解</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">SoaringInSky.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="28,132,203" opacity="0.6" zIndex="-1" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>