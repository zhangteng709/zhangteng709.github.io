<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/09/hello-world/"/>
      <url>/2018/03/09/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>my new post</title>
      <link href="/2017/03/09/my-new/"/>
      <url>/2017/03/09/my-new/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Swift中的内存泄漏</title>
      <link href="/2015/04/26/Swift%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2015/04/26/Swift%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      <content type="html"><![CDATA[<p>Swift使用自动引用计数（ARC）来管理应用程序的内存使用。在大多是情况下，并不需要考虑内存的管理。当实例不再需要的时候，ARC会自动释放这些实例所使用的内存。<br>但ARC并不是绝对安全的。下面两种情况会发生内存泄露。</p><h3 id="类实例之间的循环强引用"><a href="#类实例之间的循环强引用" class="headerlink" title="类实例之间的循环强引用"></a>类实例之间的循环强引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    var anima:Animail?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Person被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animail: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var peron:Person?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Animail初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animail被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">var animail:Animail? = Animail.init()</span><br><span class="line">person?.anima = animail</span><br><span class="line">animail?.peron = person</span><br><span class="line">person = nil;</span><br><span class="line">animail = nil;</span><br><span class="line">//测试结果（deinit未调用，则内存泄露）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Animail初始化完成</span><br></pre></td></tr></table></figure><p><strong>解决办法：使用弱引用<br>只需要将上述例子Person类的anima变量加上关键字weak，或者将Animail类的peron变量加上关键字weak。<br>当A类中包含有B类的弱引用的实例，同时，B类中存在A的强引用实例时，如果A释放，也不会影响B的释放。但A的内存回收要等到B的实例释放后才可以回收。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    var anima:Animail?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Person被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animail: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var peron:Person?</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        print(&quot;Animail初始化完成&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Animail被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">var animail:Animail? = Animail.init()</span><br><span class="line">person?.anima = animail</span><br><span class="line">animail?.peron = person</span><br><span class="line">person = nil</span><br><span class="line">animail = nil</span><br><span class="line"></span><br><span class="line">//测试结果（deinit调用，内存释放）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Animail初始化完成</span><br><span class="line">//Person被释放了</span><br><span class="line">//Animail被释放了</span><br></pre></td></tr></table></figure><hr><h3 id="闭包引起的循环强引用"><a href="#闭包引起的循环强引用" class="headerlink" title="闭包引起的循环强引用"></a>闭包引起的循环强引用</h3><p><strong>将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例，也会发生强引用循环。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var anima:Animail?</span><br><span class="line">    var age:String?</span><br><span class="line"></span><br><span class="line">    lazy var block:(() -&gt; String) = &#123;</span><br><span class="line">        if let text = self.age &#123;</span><br><span class="line">            return text</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;text is nil&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.age= name</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">person?.block()</span><br><span class="line">person = nil</span><br><span class="line">//测试结果（deinit未调用，则内存泄露）</span><br><span class="line">//Person初始化完成</span><br></pre></td></tr></table></figure><p><strong>解决办法：使用闭包捕获列表<br>当闭包和实例之间总是引用对方并且同时释放时，定义闭包捕获列表为无主引用。但捕获引用可能为nil时，定义捕获列表为弱引用。弱引用通常是可选类型，并且在实例释放后被设置为nil。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name:String = &quot;&quot;</span><br><span class="line">    var anima:Animail?</span><br><span class="line">    var age:String?</span><br><span class="line"></span><br><span class="line">    lazy var block:(() -&gt; String) = &#123;[weak self] in</span><br><span class="line">        </span><br><span class="line">        if let text = self?.jValue &#123;</span><br><span class="line">            </span><br><span class="line">            return text</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;text is nil&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.age= name</span><br><span class="line">        print(&quot;Person初始化完成&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;被释放了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在AppDelegate调用</span><br><span class="line">var person:Person? = Person.init()</span><br><span class="line">person?.block()</span><br><span class="line">person = nil</span><br><span class="line">//测试结果（deinit调用，内存释放）</span><br><span class="line">//Person初始化完成</span><br><span class="line">//Person被释放了</span><br></pre></td></tr></table></figure><ol><li>e.g<br> 我们从这个简单的实例开始：ViewController 中有一个 CustomView 类型的成员属性变量，同时 CustomView 有一个点击事件的闭包函数 onTap ：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class CustomView:UIView&#123; </span><br><span class="line">    var onTap:(()-&gt;Void)?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ViewController:UIViewController&#123; </span><br><span class="line">    let customView = CustomView() </span><br><span class="line">    var buttonClicked = false</span><br><span class="line"></span><br><span class="line">    func setupCustomView()&#123;</span><br><span class="line">        var timesTapped = 0</span><br><span class="line">        customView.onTap = &#123; _ in </span><br><span class="line">            timesTapped += 1 </span><br><span class="line">            print(&quot;button tapped \(timesTapped) times&quot;)</span><br><span class="line">            self.buttonClicked = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给闭包函数 onTap 赋值的语句中我们对 buttonClicked 进行了赋值，这就导致了对 self 的强引用。但是我们仔细思考后就不难发现其中的问题： self 引用了 customView 变量，然后 customView 变量的饮用了 onTap 闭包，最后 onTap 闭包引用了 self 。其结果类似下图：</p><p><img src="/img/aaa.png" alt=""></p><p>上图中你能清晰的看见循环结构，这导致程序退出的时候不能正常的销毁内存导致内存泄漏的发生。</p><h4 id="隐藏的循环"><a href="#隐藏的循环" class="headerlink" title="隐藏的循环"></a>隐藏的循环</h4><p>除了上面那种明显的循环引用有些闭环隐藏的更深也更隐蔽。解决这个问题的关键就是：在对闭包赋值的时候问自己谁是闭包的拥有者，然后向上溯源到根节点。</p><p>下面我们来看最常见 UITableView 中隐藏的循环（最常见的往往越容易被忽略）。一般情况下我们都是在 UIViewController 中新建 UITableView 实例少数情况下也会使用 UITableViewController ，但是不管哪种情形我们都会新建自定义的 UITableViewCell 。</p><p>下面的代码中我们新建了一个名为 CustomCell 的 UITableViewCell 子类，该类中包含了一个 UIButton实例属性以及按键点击事件的闭包属性 onButtonTap。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class CustomCell: UITableViewCell &#123;</span><br><span class="line"></span><br><span class="line">    @IBOutlet weak var customButton: UIButton!</span><br><span class="line">    var onButtonTap:(()-&gt;Void)?</span><br><span class="line"></span><br><span class="line">    @IBAction func buttonTap()&#123;</span><br><span class="line">        onButtonTap?()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///然后我们在 ViewController 对该闭包赋值：</span><br><span class="line">class ViewController: UITableViewController &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">        let cell = tableView.dequeueReusableCell(withIdentifier: &quot;CustomCell&quot;, for: indexPath) as! CustomCell</span><br><span class="line">        cell.onButtonTap = &#123; _ in</span><br><span class="line">            self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们对 onButtonTap闭包进行溯源：谁拥有该闭包？毫无疑问是 CustomCell类的实例 cell。而 cell 又是属于 tableView，tableView又属于 self 所代表的UITableViewController 实例。</p><p>正如下图表现的那样，这里也有一个循环引用，只不过分析路线更长所以显得更隐蔽。</p><p><img src="/img/bbb.png" alt=""></p><p>GCD 中的闭包分析<br>如果你以前用过 GCD 的话，那么你能一眼判断下面代码是否有循环引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    DispatchQueue.main.asyncAfter(deadline: .now() + 2) &#123;</span><br><span class="line">        self.navigationController?.pushViewController(NewViewController())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的使用溯源法分析闭包：拥有闭包的对象是 DispatchQueue 单例，该单例并不被 ViewController 任何属性所引用，但DispatchQueue 单例的闭包中却持有了 self。虽然我们不知道该单例的具体实现，但是我们清楚该异步闭包会在2s后被执行一次，执行完成之后该闭包就会释放对 self 的引用。所以我们由此可以断定这段闭包代码是不存在循环引用问题的。</p><p><strong>这部分的代码逻辑和分析同样适用于 UIView 的动画闭包函数中</strong></p><h4 id="Alamofire-中的闭包"><a href="#Alamofire-中的闭包" class="headerlink" title="Alamofire 中的闭包"></a>Alamofire 中的闭包</h4><p>Alamofire 可以说是 Swift 网络处理中最常用的第三方库了，其中的请求处理中同样涉及到闭包函数。下面这段代码是请求登陆接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Alamofire.request(&quot;https://yourapi.com/login&quot;, method: .post, parameters: [&quot;email&quot;:&quot;test@gmail.com&quot;,&quot;password&quot;:&quot;1234&quot;]).responseJSON &#123; (response:DataResponse&lt;Any&gt;) in</span><br><span class="line">    if response.response?.statusCode == 200 &#123;</span><br><span class="line">        self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //Show alert</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码中的闭包又是属于哪个对象？这里我们需要深入 Alamofire 的实现中去探寻。首先 request方法会返回一个 DataRequest类型对象，而该对象的 responseJSON方法中将闭包作为参数 completionHandler传入，最后该闭包存入了 OperationQueue 类型的队列 queue 中，闭包执行完成后会自动从队列中移除。由此我们可知：闭包被 queue所持有并且一次执行后就移除了，此处不存在循环引用。</p><p>循环引用的解决<br>为了打破循环引用带来的内存泄漏问题，根本途径就是破坏该循环，将某个对象对另一个对象的强引用去除。在闭包环境的循环问题，我们都倾向于将闭包中的强引用去除，毕竟这简单而且看起来更直观。</p><p>为了实现该目的，我们在闭包捕获的上下文变量中做文章。我们使用关键词 weak、unowned 来打破循环。例如上文中提到的 UITableView ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cell.onButtonTap = &#123; [unowned self] in</span><br><span class="line">    self.navigationController?.pushViewController(NewViewController(), animated: true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉两个关键词存在着明显的区别 weak 是可选值而 unowned 则一定不为可选值，换句话说 weak 关键词所指对象可能为 nil 而 unowned 则一定不能是 nil，因此在选用的时候需要认真考虑一下。一般来说如果闭包生命周期不长于其捕获的上下文变量的生命周期我们会使用 unowned，否则我们选择 weak 。</p><p>内存泄漏的调试<br>上面我们分析了大部分闭包中的循环引用问题，我们得知并不是所有的情况下都会导致内存泄漏。如果在我们使用了第三方库尤其是一些私有实现库的情况下，这部分的分析在代码层面将变的很困难并且工作量很大。好在Xcode为我们提供的调试工具，在工程运行的情况下，我们在调试区域可以找到如下图所示按键：</p><p><img src="/img/ccc.png" alt=""></p><p>在 UITableView 的示例中，如果我们移除闭包中的 unowned 或者 weak 的话，你就能在左侧看见下图</p><p><img src="/img/ddd.png" alt=""></p><p>上图中的左侧感叹号表明了这里存/Users/ghzz/hexo/work/source/img/aaa.png<br>在着内存泄漏的情况，这样你就要去查看代码了。当然你又内存泄漏但是没有感叹号标记的情况也是完全有可能的，此时你就要启用内存分析工具了并且分析内存中的对象，这些对象是否应该存在。</p><p>文章参考<a href="https://segmentfault.com/a/1190000008924142" target="_blank" rel="noopener">Swift闭包中的内存泄漏 </a></p>]]></content>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title> __weak、__strong、 __block 区别</title>
      <link href="/2015/04/26/weak%E3%80%81-strong%E3%80%81-block-%E5%8C%BA%E5%88%AB/"/>
      <url>/2015/04/26/weak%E3%80%81-strong%E3%80%81-block-%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>#准备工作#</p><p>首先我定义了一个类 MyObject 继承 NSObject，并添加了一个属性 text，重写了description方法，返回 text 的值。这个主要是因为编译器本身对 NSString 是有优化的，创建的 string 对象有可能是静态存储区永不释放的，为了避免使用 NSString 引起一些问题，还是创建一个 NSObject 对象比较合适。<br>另外我自定义了一个 TLog 方法输出对象相关值，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define TLog(prefix,Obj) &#123;NSLog(@&quot;变量内存地址：%p, 变量值：%p, 指向对象值：%@, --&gt; %@&quot;,&amp;Obj,Obj,Obj,prefix);&#125;</span><br></pre></td></tr></table></figure><p>__weak<br>按 Ctrl+C 复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyObject *obj = [[MyObject alloc]init];//2</span><br><span class="line">obj.text = @&quot;my-object&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;, obj);</span><br><span class="line"></span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">TLog(@&quot;weakObj&quot;, weakObj);</span><br><span class="line"></span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">&#125;;</span><br><span class="line">testBlock();</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br></pre></td></tr></table></figure><p>按 Ctrl+C 复制代码<br>变量内存地址：0x7fff58c8a9f0, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff58c8a9e8, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; weakObj<br>变量内存地址：0x7f8e030804c0, 变量值：0x7f8e0307f1d0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x7f8e030804c0, 变量值：0x0, 指向对象值：(null), –&gt; weakObj - block<br>从上面的结果可以看到</p><p>block 内的 weakObj 和外部的 weakObj 并不是同一个变量<br>block 捕获了 weakObj 同时也是对 obj 进行了弱引用，当我在 block 外把 obj 释放了之后，block 内也读不到这个变量了<br>当 obj 赋值 nil 时，block 内部的 weakObj 也为 nil 了，也就是说 obj 实际上是被释放了，可见 __weak 是可以避免循环引用问题的<br>接下来我们再看第二段代码</p><p>复制代码<br><figure class="highlight plain"><figcaption><span>*obj </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">obj.text = @&quot;my-object&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;, obj);</span><br><span class="line">    </span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">TLog(@&quot;weakObj-0&quot;, weakObj);</span><br><span class="line">    </span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TLog(@&quot;weakObj-1&quot;, weakObj);</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;weakObj-2&quot;, weakObj);</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;weakObj-3&quot;, weakObj);</span><br></pre></td></tr></table></figure></p><p>复制代码<br>复制代码<br>变量内存地址：0x7fff5d7b2d18, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-0<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-1<br>变量内存地址：0x7fcf78f0f520, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x7fff5d7b2bb8, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; strongObj - block<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x7fcf78c11e80, 指向对象值：my-object, –&gt; weakObj-2<br>变量内存地址：0x7fcf78f0f520, 变量值：0x0, 指向对象值：(null), –&gt; weakObj - block<br>变量内存地址：0x7fff5d7b2bb8, 变量值：0x0, 指向对象值：(null), –&gt; strongObj - block<br>变量内存地址：0x7fff5d7b2d10, 变量值：0x0, 指向对象值：(null), –&gt; weakObj-3<br>复制代码</p><p>如果你看过 AFNetworking 的源码，会发现 AFN 中作者会把变量在 block 外面先用 <strong>weak 声明，在 block 内把前面 weak 声明的变量赋值给 </strong>strong 修饰的变量这种写法。</p><p>从上面例子我们看到即使在 block 内部用 strong 强引用了外面的 weakObj ，但是一旦 obj 释放了之后，内部的 strongObj 同样会变成 nil，那么这种写法又有什么意义呢？</p><p>下面再看一段代码：</p><p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;my-object&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;, obj);</span><br><span class="line">    </span><br><span class="line">__weak MyObject *weakObj = obj;</span><br><span class="line">TLog(@&quot;weakObj-0&quot;, weakObj);</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">   </span><br><span class="line">   sleep(3);</span><br><span class="line">   </span><br><span class="line">   TLog(@&quot;weakObj - block&quot;, weakObj);</span><br><span class="line">   TLog(@&quot;strongObj - block&quot;, strongObj);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;------ sleep 1s&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">obj = nil;</span><br><span class="line">TLog(@&quot;weakObj-1&quot;, weakObj);</span><br><span class="line">NSLog(@&quot;------ sleep 5s&quot;);</span><br><span class="line">sleep(5);</span><br><span class="line">TLog(@&quot;weakObj-2&quot;, weakObj);</span><br></pre></td></tr></table></figure></p><p>复制代码<br>复制代码<br>变量内存地址：0x7fff58e2ad18, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; obj<br>变量内存地址：0x7fff58e2ad10, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj-0<br>变量内存地址：0x7fa2b1e80710, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x700000093de8, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; strongObj - block<br>—— sleep 1s<br>变量内存地址：0x7fff58e2ad10, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj-1<br>—— sleep 5s<br>变量内存地址：0x7fa2b1e80710, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; weakObj - block<br>变量内存地址：0x700000093de8, 变量值：0x7fa2b1e804e0, 指向对象值：my-object, –&gt; strongObj - block<br>变量内存地址：0x7fff58e2ad10, 变量值：0x0, 指向对象值：(null), –&gt; weakObj-2<br>复制代码</p><p>代码中使用 sleep 来保证代码执行的先后顺序。</p><p>从结果中我们可以看到，只要 block 部分执行了，即使我们中途释放了 obj，block 内部依然会继续强引用它。对比上面代码，也就是说 block 内部的 __strong 会在执行期间进行强引用操作，保证在 block 内部 strongObj 始终是可用的。这种写法非常巧妙，既避免了循环引用的问题，又可以在 block 内部持有该变量。</p><p>综合两部分代码，我们平时在使用时，常常先判断 strongObj 是否为空，然后再执行后续代码，如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">   __strong MyObject *strongObj = weakObj;</span><br><span class="line">   if (strongObj) &#123;</span><br><span class="line">       // do something ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这种方式先判断 Obj 是否被释放，如果未释放在执行我们的代码的时候保证其可用性。</p><p>###__block<br>先上代码</p><p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;my-object-1&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">TLog(@&quot;blockObj -1&quot;,blockObj);</span><br><span class="line"></span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">    MyObject *obj2 = [[MyObject alloc]init];</span><br><span class="line">    obj2.text = @&quot;my-object-2&quot;;</span><br><span class="line">    TLog(@&quot;obj2&quot;,obj2);</span><br><span class="line">    blockObj = obj2;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,testBlock);</span><br><span class="line">TLog(@&quot;blockObj -2&quot;,blockObj);</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj -3&quot;,blockObj);</span><br></pre></td></tr></table></figure></p><p>复制代码<br>复制代码<br>变量内存地址：0x7fff5021a9f0, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; obj<br>变量内存地址：0x7fff5021a9e8, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj -1<br>&lt;<strong>NSMallocBlock</strong>: 0x7ff6b48d8c20&gt;<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj -2<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d8cd0, 指向对象值：my-object-1, –&gt; blockObj - block<br>变量内存地址：0x7fff5021a7f8, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; obj2<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; blockObj - block<br>变量内存地址：0x7ff6b48da518, 变量值：0x7ff6b48d9960, 指向对象值：my-object-2, –&gt; blockObj -3<br>复制代码</p><p>可以看到在 block 声明前后 blockObj 的内存地址是有所变化的，这涉及到 block 对外部变量的内存管理问题，大家可以看扩展阅读中的几篇文章，对此有较深入的分析。</p><p>下面来看看 __block 能不能避免循环引用的问题</p><p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;11111111111111&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">&#125;;</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj&quot;,blockObj);</span><br></pre></td></tr></table></figure></p><p>复制代码<br>变量内存地址：0x7fff57eef9f0, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; obj<br>变量内存地址：0x7ff86c918a88, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; blockObj - block<br>变量内存地址：0x7ff86c918a88, 变量值：0x7ff86a55a160, 指向对象值：11111111111111, –&gt; blockObj</p><p>当外部 obj 指向 nil 的时候，obj 理应被释放，但实际上 blockObj 依然强引用着 obj，obj 其实并没有被真正释放。因此使用 __block 并不能避免循环引用的问题。</p><p>但是我们可以通过手动释放 blockObj 的方式来释放 obj，这就需要我们在 block 内部将要退出的时候手动释放掉 blockObj ，如下这种形式</p><p>复制代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyObject *obj = [[MyObject alloc]init];</span><br><span class="line">obj.text = @&quot;11111111111111&quot;;</span><br><span class="line">TLog(@&quot;obj&quot;,obj);</span><br><span class="line"></span><br><span class="line">__block MyObject *blockObj = obj;</span><br><span class="line">obj = nil;</span><br><span class="line">void(^testBlock)() = ^()&#123;</span><br><span class="line">    TLog(@&quot;blockObj - block&quot;,blockObj);</span><br><span class="line">    blockObj = nil;</span><br><span class="line">&#125;;</span><br><span class="line">obj = nil;</span><br><span class="line">testBlock();</span><br><span class="line">TLog(@&quot;blockObj&quot;,blockObj);</span><br></pre></td></tr></table></figure></p><p>复制代码</p><p>必须记住在 block 底部释放掉 block 变量，这其实跟 MRC 的形式有些类似了，不太适合 ARC这种形式既能保证在 block 内部能够访问到 obj，又可以避免循环引用的问题，但是这种方法也不是完美的，其存在下面几个问题</p><p>当在 block 外部修改了 blockObj 时，block 内部的值也会改变，反之在 block 内部修改 blockObj 在外部再使用时值也会改变。这就需要在写代码时注意这个特性可能会带来的一些隐患<br>__block 其实提升了变量的作用域，在 block 内外访问的都是同一个 blockObj 可能会造成一些隐患</p><p>总结！！！<br><strong>weak 本身是可以避免循环引用的问题的，但是其会导致外部对象释放了之后，block 内部也访问不到这个对象的问题，我们可以通过在 block 内部声明一个 </strong>strong 的变量来指向 weakObj，使外部对象既能在 block 内部保持住，又能避免循环引用的问题。</p><p><strong>block 本身无法避免循环引用的问题，但是我们可以通过在 block 内部手动把 blockObj 赋值为 nil 的方式来避免循环引用的问题。另外一点就是 </strong>block 修饰的变量在 block 内外都是唯一的，要注意这个特性可能带来的隐患。</p><p>但是<strong>block有一点：这只是限制在ARC环境下。在非arc下，</strong>block是可以避免引用循环的</p>]]></content>
      
      
    </entry>
    
  
  
</search>
